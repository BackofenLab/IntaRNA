
#include "PredictionTrackerBasePairProb.h"

#include <bits/std_abs.h>
#include <bits/unordered_map.h>
#include <boost/lexical_cast.hpp>
#include <boost/numeric/ublas/matrix.hpp>
#include <stddef.h>
#include <ViennaRNA/datastructures/basic.h>
#include <ViennaRNA/utils/structures.h>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cwchar>
#include <stdexcept>
#include <string>

#include "../easylogging++.h"
#include "general.h"
#include "intarna_config.h"
#include "ReverseAccessibility.h"
#include "RnaSequence.h"
#include "SeedConstraint.h"
#include "SeedHandler.h"

extern "C" {
	#include <ViennaRNA/vrna_config.h>
	#include <ViennaRNA/plotting/probabilities.h>
}

#include <boost/foreach.hpp>
#include <boost/regex.hpp>

namespace IntaRNA {

const Interaction::BasePair bpToTrack(1,1);

//////////////////////////////////////////////////////////////////////

PredictionTrackerBasePairProb::
PredictionTrackerBasePairProb(
		const InteractionEnergy & energy
		, const std::string & fileName
	)
 :	PredictionTracker()
	, energy(energy)
	, fileName(fileName)
	, probabilityThreshold(0.0001)
	, maxDotPlotSize(1000)
{
}

//////////////////////////////////////////////////////////////////////

PredictionTrackerBasePairProb::
~PredictionTrackerBasePairProb()
{
}

//////////////////////////////////////////////////////////////////////

void
PredictionTrackerBasePairProb::
updateOptimumCalled( const size_t i1, const size_t j1
					, const size_t i2, const size_t j2
					, const E_type curE
					)
{
}

//////////////////////////////////////////////////////////////////////

void
PredictionTrackerBasePairProb::
updateZ( PredictorMfeEns *predictor, SeedHandler *seedHandler )
{
	PredictorMfeEns2dSeedExtension* seedPredictor = dynamic_cast<PredictorMfeEns2dSeedExtension*>(predictor);
	isSeedPredictor = (seedPredictor != nullptr);

	// sequence strings
	const std::string & rna1 = energy.getAccessibility1().getSequence().asString();
	const std::string & reverseRna2 = energy.getAccessibility2().getAccessibilityOrigin().getSequence().asString();

	size_t s1 = energy.size1();
	size_t s2 = energy.size2();
	size_t n1 = energy.getAccessibility1().getMaxLength();
	size_t n2 = energy.getAccessibility2().getMaxLength();

	Z_type maxZ = 0.0;
	Interaction::Boundary interactionBoundary;

	// initialize Z_partition
	const PredictorMfeEns::Site2Z_hash & Z_partition = predictor->getZPartition();

	// for (auto z = Z_partition.begin(); z != Z_partition.end(); ++z) {
	// 	LOG(DEBUG) << z->first.i1 << ":" << z->first.j1 << ":" << z->first.i2 << ":" << z->first.j2 << "=" << z->second;
	// }

	// create index of left/right boundaries
	for (auto z = Z_partition.begin(); z != Z_partition.end(); ++z) {
		// identify best interaction boundary
		Z_type Zstruct = z->second * energy.getBoltzmannWeight(energy.getE(z->first.i1, z->first.j1, z->first.i2, z->first.j2, E_type(0)));
		if (Zstruct > maxZ) {
			maxZ = Zstruct;
			interactionBoundary = z->first;
		}

		Interaction::BasePair iBP(z->first.i1, z->first.i2);
		Interaction::BasePair jBP(z->first.j1, z->first.j2);

		// create left and jBP index
		if (z->first.i1 != z->first.j1 && z->first.i2 != z->first.j2) {
			// encode iBP/jBP boundary
			// create left index
			rightExt[iBP].insert(jBP);
			// create right index
			if (seedHandler != NULL) {
				leftExt[jBP].insert(iBP);
			}
		}

	} // it (Z_partition)

	// Compute base-pair probabilities via combinations
	if (!isSeedPredictor) {
		computeBasePairProbsNoSeed(predictor);
	} else {
		computeBasePairProbs(seedPredictor, seedHandler);
	}

	// build plist
	struct vrna_elem_prob_s plist[structureProbs.size()+1];
	size_t i = 0;
	const Z_type Zall = predictor->getZall();
	for (auto sp = structureProbs.begin(); sp != structureProbs.end(); ++sp) {
		LOG_IF(Interaction::BasePair(sp->first.first,sp->first.second)==bpToTrack,DEBUG) << "prob: " << toString(bpToTrack) << " = " << sp->second <<"   Z = "<<sp->second*predictor->getZall();
		if ( (sp->second /Zall)  > probabilityThreshold) {
			plist[i].i = sp->first.first + 1;
			plist[i].j = sp->first.second + 1;
			plist[i].p = (sp->second /Zall);
			plist[i].type = 0; // base-pair prob
			i++;
		}
	}

	// create dot plot
	char *name = strdup(fileName.c_str());
	std::string comment =
	  "Intermolecular base-pair probabilities generated by "
	  INTARNA_PACKAGE_STRING
    " using Vienna RNA package "
    VRNA_VERSION;

	generateDotPlot(strdup(rna1.c_str()), strdup(reverseRna2.c_str()), name, plist, comment.c_str(), interactionBoundary);

}

////////////////////////////////////////////////////////////////////////////

void
PredictionTrackerBasePairProb::
computeBasePairProbsNoSeed( const PredictorMfeEns *predictor )
{
	for (auto z = predictor->getZPartition().begin(); z != predictor->getZPartition().end(); ++z) {
		assert( !Z_equal(z->second, 0) );

		Z_type bpProb = z->second * energy.getBoltzmannWeight(energy.getE(z->first.i1, z->first.j1, z->first.i2, z->first.j2, E_type(0)));

		Interaction::BasePair iBP(z->first.i1, z->first.i2);
		Interaction::BasePair jBP(z->first.j1, z->first.j2);

		// left end and single bp
		updateProb(iBP, bpProb);

		if (iBP < jBP) {
			// right end
			updateProb(jBP, bpProb);

			// inner (rightExt > jBP)
			for (auto right = rightExt[jBP].begin(); right != rightExt[jBP].end(); ++right) {
				Z_type innerProb = z->second * getHybridZ(z->first.j1, right->first, z->first.j2, right->second, predictor)
									 * energy.getBoltzmannWeight(energy.getE(z->first.i1, right->first, z->first.i2, right->second, -energy.getE_init()));
				updateProb(jBP, innerProb);
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////

void
PredictionTrackerBasePairProb::
computeBasePairProbs( const PredictorMfeEns2dSeedExtension *predictor, const SeedHandler* seedHandler )
{
	auto ZL_partition = predictor->getZLPartition();
	size_t i1, j1, i2, j2;
	for (auto z = predictor->getZPartition().begin(); z != predictor->getZPartition().end(); ++z) {
		i1 = z->first.i1;
		j1 = z->first.j1;
		i2 = z->first.i2;
		j2 = z->first.j2;

		LOG(DEBUG) << "region @ " << i1 << ":" << j1 << ":" << i2 << ":" << j2;

		Z_type bpZ;
		// i external left
		bpZ = getHybridZ(i1, j1, i2, j2, predictor)
				* energy.getBoltzmannWeight(energy.getE(i1, j1, i2, j2, E_type(0)));
		updateProb(Interaction::BasePair(i1,i2), bpZ);
		LOG_IF(i1 == 3 && i2 == 3, DEBUG) << "ext left @ " << i1 << ":" << i2 << " = " << bpZ;

		// j external right (and not single bp)
		if (i1!=j1) {
			updateProb(Interaction::BasePair(j1,j2), bpZ);
			LOG_IF(j1 == 3 && j2 == 3, DEBUG) << "ext right @ " << j1 << ":" << j2 << " = " << bpZ;
		}

		Z_type tempZ;

		// loop internal k (inbetween i and j)
		for (size_t k1 = i1+1; k1 < j1; k1++) {
			for (size_t k2 = i2+1; k2 < j2; k2++) {

				Interaction::BasePair kBP(k1, k2);
				bpZ = 0;

				// k internal
				Z_type ZSleft = getHybridZ(i1, k1, i2, k2, predictor);
				Z_type ZSright = getHybridZ(k1, j1, k2, j2, predictor);

				// ... ZS:ZS
				bpZ += ZSleft * ZSright / energy.getBoltzmannWeight(energy.getE_init());
				LOG_IF(k1 == 3 && k2 == 3, DEBUG) << "int ZS:ZS @ " << k1 << ":" << k2 << " = " << bpZ;

				// ... ZS:ZP
				if (!Z_equal(ZSleft, 0.0)) {
					tempZ = ZSleft
							* (getZHPartition(predictor, seedHandler, k1, j1, k2, j2, false) - ZSright) / energy.getBoltzmannWeight(energy.getE_init());
					bpZ += tempZ;
					LOG_IF(k1 == 3 && k2 == 3, DEBUG) << "int ZS:ZP @ " << k1 << ":" << k2 << " = " << tempZ;
				}

				// ... ZP:ZS
				if (!Z_equal(ZSright, 0.0)) {
					tempZ = (getZHPartition(predictor, seedHandler, i1, k1, i2, k2, true) - ZSleft) / energy.getBoltzmannWeight(energy.getE_init())
							* ZSright;
					bpZ += tempZ;
					LOG_IF(k1 == 3 && k2 == 3, DEBUG) << "int ZP:ZS @ " << k1 << ":" << k2 << " = " << tempZ;
				}

				// ... ZNL:seed:ZNR
				{
				size_t si1 = RnaSequence::lastPos, si2 = RnaSequence::lastPos;
				const size_t seedBP = seedHandler->getConstraint().getBasePairs();
				size_t maxSeedLength1 = (seedBP - std::max((size_t)2,seedBP)) + seedHandler->getConstraint().getMaxUnpaired1();
				size_t maxSeedLength2 = (seedBP - std::max((size_t)2,seedBP)) + seedHandler->getConstraint().getMaxUnpaired2();
				tempZ = 0.0;
				while( seedHandler->updateToNextSeed(si1,si2
						, k1-std::min(k1, maxSeedLength1)
						, k1-1  // k1 > 0
						, k2-std::min(k2, maxSeedLength2)
						, k2-1) ) // k2 > 0
				{
					if (seedHandler->isSeedBasePair(si1, si2, k1, k2)) {
						// check if still in region
						assert(si1 < i1 || si2 < i2);
						if (si1+seedHandler->getSeedLength1(si1,si2)-1 > j1 || si2+seedHandler->getSeedLength2(si1,si2)-1 > j2) continue;
						tempZ += getZPartitionValue(&ZL_partition, Interaction::Boundary(i1,si1,i2,si2), false) // contains E_init
									* energy.getBoltzmannWeight(seedHandler->getSeedE(si1, si2))
									* getZRPartition(predictor, seedHandler, si1+seedHandler->getSeedLength1(si1,si2)-1, j1, si2+seedHandler->getSeedLength2(si1,si2)-1, j2, si1, si2);
						LOG_IF(k1 == 3 && k2 == 3, DEBUG) << "found seed @" << si1 << ":" << si2 << "=" << getZPartitionValue(&ZL_partition, Interaction::Boundary(i1,si1,i2,si2), false) << ":" << energy.getBoltzmannWeight(seedHandler->getSeedE(si1, si2)) << ":" << getZRPartition(predictor, seedHandler, si1+seedHandler->getSeedLength1(si1,si2)-1, j1, si2+seedHandler->getSeedLength2(si1,si2)-1, j2, si1, si2);
						LOG_IF(k1 == 3 && k2 == 3, DEBUG) << "-----" << ZL_partition.find(Interaction::Boundary(i1,si1,i2,si2))->second;
					}
				}

				bpZ += tempZ;
				LOG_IF(k1 == 3 && k2 == 3, DEBUG) << "int ZNL:seed:ZNR @ " << k1 << ":" << k2 << " = " << tempZ;
				}

				// add ED values, dangling ends, etc.
				bpZ *= energy.getBoltzmannWeight(energy.getE(i1, j1, i2, j2, E_type(0)));
				updateProb(kBP, bpZ);

			} // k2
		} // k1
	} // Z_partitions
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getZPartitionValue( const Site2Z_hash *Zpartition, const Interaction::Boundary & boundary, const bool addZInit )
{
	auto keyEntry = Zpartition->find(boundary);
	if ( Zpartition->find(boundary) == Zpartition->end() ) {
		return 0;
	} else {
		if (addZInit) {
      return keyEntry->second * energy.getBoltzmannWeight(energy.getE_init());
		} else {
			return keyEntry->second;
		}
	}
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getZHPartition( const PredictorMfeEns2dSeedExtension *predictor, const SeedHandler* seedHandler
              , const size_t i1, const size_t j1
	            , const size_t i2, const size_t j2
							, const bool leftSide )
{
	// sanity check
	if (!energy.areComplementary(i1,i2) || !energy.areComplementary(j1,j2)) {
		return Z_type(0);
	}
	// single bp boundary with ZH == 1
	if (i1==j1 && i1==j2) {
		return Z_type(1);
	}
	Interaction::Boundary boundary(i1,j1,i2,j2);

	// TODO : sollte für left/right gleich sein (leftSide switch + fillHybridZ_right obsolete)

	// LOG(DEBUG) << "request ZH @ " << i1 << ":" << j1 << ":" << i2 << ":" << j2;

	// check if ZH available from predictor
	Z_type ZH = getZPartitionValue(&predictor->getZHPartition(), boundary, true);
	if (Z_equal(ZH, 0.0)) {
		// check if ZH available in missing ZH partitions
		auto ZHentry = ZH_partition_missing.find(boundary);
		if ( ZHentry != ZH_partition_missing.end() ) {
			ZH = ZHentry->second;
		} else {
//			if (leftSide) {
			ZH = fillHybridZ_left(i1, j1, i2, j2, seedHandler);
//			} else {
//        fillHybridZ_right(i1, j1, i2, j2, seedHandler);
//			}
//			ZH = ZH_partition_missing.find(boundary)->second;
		}
	}

	return ZH;
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getZRPartition( const PredictorMfeEns2dSeedExtension *predictor, const SeedHandler* seedHandler
              , const size_t i1, const size_t j1
	            , const size_t i2, const size_t j2
							, const size_t sa1, const size_t sa2 )
{
	// TODO: memoization

	// single bp boundary with ZNR == 1
	if (i1==j1 && i1==j2 && energy.areComplementary(i1,i2)) {
		return Z_type(1);
	}
	Interaction::Boundary boundary(i1,j1,i2,j2);
	// LOG(DEBUG) << "request ZR @ " << i1 << ":" << j1 << ":" << i2 << ":" << j2;

	Z_type partZ = getZHPartition(predictor, seedHandler, i1, j1, i2, j2, false);
	Z_type ZS = getHybridZ(boundary, predictor);
	assert( ZS <= partZ );
	partZ -= ZS;

	// remove Einit
	partZ /= energy.getBoltzmannWeight(energy.getE_init());

	// iterate all seeds that overlap anchor seed sa on the right side
	size_t si1 = RnaSequence::lastPos, si2 = RnaSequence::lastPos;
	const size_t seedBP = seedHandler->getConstraint().getBasePairs();
	size_t maxSeedLength1 = (seedBP - std::max((size_t)2,seedBP)) + seedHandler->getConstraint().getMaxUnpaired1();
	size_t maxSeedLength2 = (seedBP - std::max((size_t)2,seedBP)) + seedHandler->getConstraint().getMaxUnpaired2();
	while( seedHandler->updateToNextSeed(si1,si2
			, i1-std::min(i1, maxSeedLength1)
			, i1-1 // i1 > 0
			, i2-std::min(i2, maxSeedLength2)
			, i2-1) ) // i2 > 0
	{
		if (seedHandler->isSeedBasePair(si1, si2, i1, i2)) {
			// LOG(DEBUG) << "overlapping seed @ " << si1 << ":" << si2;
			size_t sj1 = si1 + seedHandler->getSeedLength1(si1, si2) - 1;
			size_t sj2 = si2 + seedHandler->getSeedLength2(si1, si2) - 1;
			// check if still in region
			assert(si1 < sa1 || si2 < sa2);
			if (sj1 > j1 || sj2 > j2) continue;
			if (seedHandler->areLoopOverlapping(sa1,sa2,si1,si2)) {
				E_type Eoverlap = seedHandler->getSeedE(sa1, sa2)
								- PredictorMfeEns2dSeedExtension::getNonOverlappingEnergy(sa1, sa2, si1, si2, energy, *seedHandler);
				Z_type corrZterm = energy.getBoltzmannWeight(seedHandler->getSeedE(si1, si2) - Eoverlap)
					   * getZRPartition(predictor, seedHandler, sj1, j1, sj2, j2, si1, si2);
				assert(corrZterm <= partZ);
				partZ -= corrZterm;
			}
		}
	}

	return partZ;
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getHybridZ( const size_t i1, const size_t j1
					, const size_t i2, const size_t j2
					, const PredictorMfeEns *predictor)
{
	Interaction::Boundary boundary(i1, j1, i2, j2);
	return getHybridZ(boundary, predictor);
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getHybridZ( const Interaction::Boundary & boundary
					, const PredictorMfeEns *predictor)
{
	// check in original data
	if ( predictor->getZPartition().find(boundary) != predictor->getZPartition().end() ) {
		return predictor->getZPartition().find(boundary)->second;
	} else {
		// fall back
		return Z_type(0);
	}
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getBasePairProb( const size_t i1, const size_t i2
					     , const PredictorMfeEns *predictor)
{
	Interaction::BasePair bp(i1, i2);
	if ( structureProbs.find(bp) == structureProbs.end() ) {
		return Z_type(0);
	} else {
		return structureProbs[bp] / predictor->getZall();
	}
}

////////////////////////////////////////////////////////////////////////////

void
PredictionTrackerBasePairProb::
fillHybridZ_right( const size_t sj1, const size_t r1, const size_t sj2, const size_t r2, const SeedHandler* seedHandler )
{

#if INTARNA_IN_DEBUG_MODE
	// check indices
	if (!energy.areComplementary(sj1,sj2) )
		throw std::runtime_error("PredictionTrackerBasePairProb::fillHybridZ_right("+toString(sj1)+","+toString(sj2)+",..) are not complementary");
#endif

  hybridZ_right.resize( r1-sj1+1, r2-sj2+1 );

	// global vars to avoid reallocation
	size_t j1,j2,k1,k2;

	// determine whether or not lonely base pairs are allowed or if we have to
	// ensure a stacking to the right of the left boundary (i1,i2)
	const size_t noLpShift = seedHandler->getConstraint().isLpAllowed() ? 0 : 1;
	Z_type iStackZ = Z_type(1);

	// iterate over all window ends j1 (seq1) and j2 (seq2)
	for (j1=sj1; j1-sj1 < hybridZ_right.size1(); j1++ ) {
		for (j2=sj2; j2-sj2 < hybridZ_right.size2(); j2++ ) {

			// referencing cell access
			Z_type & curZ = hybridZ_right(j1-sj1,j2-sj2);

			// init partition function for current cell -> (i1,i2) are complementary per definition
			curZ = sj1==j1 && sj2==j2 ? energy.getBoltzmannWeight(energy.getE_init()) : 0.0;

			// check if complementary free base pair
			if( sj1<j1 && sj2<j2 && energy.areComplementary(j1,j2) ) {

				// left-stacking of j if no-LP
				if (!seedHandler->getConstraint().isLpAllowed()) {
					// skip if no stacking possible
					if (!energy.areComplementary(j1-noLpShift,j2-noLpShift)) {
						continue;
					}
					// get stacking energy to avoid recomputation in recursion below
					iStackZ = energy.getBoltzmannWeight(energy.getE_interLeft(j1-noLpShift,j1,j2-noLpShift,j2));
					// check just stacked seed extension
					if (j1-noLpShift==sj1 && j2-noLpShift==sj2) {
						curZ += iStackZ * hybridZ_right(0,0);
					}
				}

				// check all combinations of decompositions into (i1,i2)..(k1,k2)-(j1,j2)
				for (k1=j1-noLpShift; k1-- > sj1; ) {
					// ensure maximal loop length
					if (j1-noLpShift-k1 > energy.getMaxInternalLoopSize1()+1) break;
					for (k2=j2-noLpShift; k2-- > sj2; ) {
						// ensure maximal loop length
						if (j2-noLpShift-k2 > energy.getMaxInternalLoopSize2()+1) break;
						// check if (k1,k2) are valid left boundary
						if ( ! Z_equal(hybridZ_right(k1-sj1,k2-sj2), 0.0) ) {
							// update partition function
							curZ += ( hybridZ_right(k1-sj1,k2-sj2)
									* energy.getBoltzmannWeight(energy.getE_interLeft(k1,j1-noLpShift,k2,j2-noLpShift))
									* iStackZ );
						}
					} // k2
				} // k1
			} // complementary

			// store partial Z
			Interaction::Boundary key(sj1,j1,sj2,j2);
			auto keyEntry = ZH_partition_missing.find(key);
			if ( ZH_partition_missing.find(key) == ZH_partition_missing.end() ) {
				ZH_partition_missing[key] = curZ;
			}
		}
	}

}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
fillHybridZ_left( const size_t l1, const size_t si1, const size_t l2, const size_t si2, const SeedHandler* seedHandler )
{
#if INTARNA_IN_DEBUG_MODE
	// check indices
	if (!energy.areComplementary(si1,si2) )
		throw std::runtime_error("PredictorMfeEns2dSeedExtension::fillHybridZ_left("+toString(si1)+","+toString(si2)+",..) are not complementary");
#endif

  hybridZ_left.resize( si1-l1+1, si2-l2+1 );

	// global vars to avoid reallocation
	size_t i1,i2,k1,k2;

	// determine whether or not lonely base pairs are allowed or if we have to
	// ensure a stacking to the right of the left boundary (i1,i2)
	const size_t noLpShift = seedHandler->getConstraint().isLpAllowed() ? 0 : 1;
	Z_type iStackZ = Z_type(1);

	Z_type overallZ = Z_type(0);

	// iterate over all window starts i1 (seq1) and i2 (seq2)
	for (size_t l1=0; l1 < hybridZ_left.size1(); l1++) {
		for (size_t l2=0; l2 < hybridZ_left.size2(); l2++) {
			i1 = si1-l1;
			i2 = si2-l2;

			// referencing cell access
			Z_type & curZ = hybridZ_left(si1-i1,si2-i2);

			// init current cell (0 if not just right-most (j1,j2) base pair)
			curZ = (i1==si1 && i2==si2) ? energy.getBoltzmannWeight(energy.getE_init()) : 0.0;

			// check if complementary (use global sequence indexing)
			if( i1<si1 && i2<si2 && energy.areComplementary(i1,i2) ) {

				// right-stacking of i if no-LP
				if (!seedHandler->getConstraint().isLpAllowed()) {
					// skip if no stacking possible
					if (!energy.areComplementary(i1+noLpShift,i2+noLpShift)) {
						continue;
					}
					// get stacking energy to avoid recomputation in recursion below
					iStackZ = energy.getBoltzmannWeight(energy.getE_interLeft(i1,i1+noLpShift,i2,i2+noLpShift));
					// check just stacked
					curZ += iStackZ + hybridZ_left(l1-noLpShift,l2-noLpShift);
				}

				// check all combinations of decompositions into (i1,i2)..(k1,k2)-(j1,j2)
				for (k1=i1+noLpShift; k1++ < si1; ) {
					// ensure maximal loop length
					if (k1-i1-noLpShift > energy.getMaxInternalLoopSize1()+1) break;
					for (k2=i2+noLpShift; k2++ < si2; ) {
						// ensure maximal loop length
						if (k2-i2-noLpShift > energy.getMaxInternalLoopSize2()+1) break;
						// check if (k1,k2) are valid left boundary
						if ( ! Z_equal(hybridZ_left(si1-k1,si2-k2), 0.0) ) {
							curZ += (iStackZ
									* energy.getBoltzmannWeight(energy.getE_interLeft(i1+noLpShift,k1,i2+noLpShift,k2))
									* hybridZ_left(si1-k1,si2-k2));
						}
					} // k2
				} // k1
			} // complementary

			// store partial Z
			Interaction::Boundary key(i1,si1,i2,si2);
			auto keyEntry = ZH_partition_missing.find(key);
			if ( ZH_partition_missing.find(key) == ZH_partition_missing.end() ) {
				ZH_partition_missing[key] = curZ;
			}
			// store Z of full region for return value
			if (i1 == l1 && i2 == l2) {
				overallZ = curZ;
			}

		} // i2
	} // i1

	return overallZ;
}

////////////////////////////////////////////////////////////////////////////

bool
PredictionTrackerBasePairProb::
generateDotPlot( const char *seq1, const char *seq2, const char *fileName
							 , const plist *pl, const char *comment
						   , const Interaction::Boundary interactionBoundary )
{
	FILE *file;
	file = fopen(fileName,"w");
	if (file == NULL) return false; /* failure */

	int bbox[4];
	bbox[0] = 0;
	bbox[1] = 0;
	bbox[2] = 72 * (strlen(seq1) + 3);
	bbox[3] = 72 * (strlen(seq2) + 3);

	size_t maxSize = std::max(bbox[2], bbox[3]);
	float scale = 1;
	if (maxSize > maxDotPlotSize) {
		scale = maxDotPlotSize / (float)maxSize;
		bbox[2] *= scale;
		bbox[3] *= scale;
	}

	fprintf(file,
          "%%!PS-Adobe-3.0 EPSF-3.0\n"
          "%%%%Creator: IntaRNA\n"
          "%%%%Title: RNA Dot Plot\n"
          "%%%%BoundingBox: %d %d %d %d\n"
          "%%%%DocumentFonts: Helvetica\n"
          "%%%%Pages: 1\n"
          "%%%%EndComments\n",
          bbox[0], bbox[1], bbox[2], bbox[3]);

	// scaling
	fprintf(file,
		      "%%%%BeginProcSet: epsffit 1 0\n"
		      "gsave\n"
		      "%f 0 translate\n"
	        "%f %f scale\n"
		      "%%%%EndProcSet\n\n",
				  scale, scale, scale);

  // comment

	if (comment) {
    fprintf(file, "%%%% %s\n", comment);
  }

	fprintf(file, "/DPdict 100 dict def\n");
	fprintf(file, "DPdict begin\n");

	// ps template

	fprintf(file, dotplotTemplate);
  fprintf(file, "end\n");
	fprintf(file, "DPdict begin\n");

	// sequences

	unsigned int i, length;
  length = strlen(seq1);
  fprintf(file, "/sequence1 { (\\\n");
  i = 0;
  while (i < length) {
    fprintf(file, "%.255s\\\n", seq1 + i);  /* no lines longer than 255 */
    i += 255;
  }
  fprintf(file, ") } def\n");
	fprintf(file, "/len { sequence1 length } bind def\n\n");
	length = strlen(seq2);
  fprintf(file, "/sequence2 { (\\\n");
  i = 0;
  while (i < length) {
    fprintf(file, "%.255s\\\n", seq2 + i);  /* no lines longer than 255 */
    i += 255;
  }
  fprintf(file, ") } def\n");
	fprintf(file, "/len2 { sequence2 length } bind def\n\n");

	fprintf(file, "72 72 translate\n"
	               "72 72 scale\n");

  fprintf(file, "/Helvetica findfont 0.95 scalefont setfont\n\n");

	fprintf(file,"drawseq1\n");
	fprintf(file,"drawseq2\n");

	// basepair data

	fprintf(file,"%%data starts here\n");

	fprintf(file, "\n%%draw the grid\ndrawgrid\n\n");
	fprintf(file,"%%start of base pair probability data\n");

  fprintf(file, "/coor [\n");

	for (const plist *pl1 = pl; pl1->i > 0; pl1++) {
    if (pl1->type == 0) {
      fprintf(file, "%1.9f %d %d boxgray\n", sqrt(pl1->p), pl1->i, pl1->j);
    }
  }

  fprintf(file, "] def\n");

	// print frame
	fprintf(file,
		      "0.03 setlinewidth\n\
           %1.1f %1.1f %zu %zu rectangle\n\
					 0 0 0 setrgbcolor\n\
           stroke\n", 0.5, 0.5, strlen(seq1), strlen(seq2));

	// print best interaction outline
	fprintf(file,
		      "0.03 setlinewidth\n\
           %1.1f %1.1f %zu %zu rectangle\n\
					 1 0 0 setrgbcolor\n\
           stroke\n", (float)interactionBoundary.i1 + 0.5, (float)interactionBoundary.i2 + 0.5, interactionBoundary.j1 - interactionBoundary.i1 + 1, interactionBoundary.j2 - interactionBoundary.i2 + 1);

	fprintf(file, "showpage\n"
	            "end\n"
              "%%%%EOF\n");

	fclose(file);
	return true; /* success */
}

////////////////////////////////////////////////////////////////////////////

} // namespace
