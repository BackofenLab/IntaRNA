
#include "IntaRNA/PredictionTrackerBasePairProb.h"

extern "C" {
	#include <ViennaRNA/vrna_config.h>
	#include <ViennaRNA/plotting/probabilities.h>
}

#include <boost/foreach.hpp>
#include <boost/regex.hpp>

namespace IntaRNA {

const Interaction::BasePair bpToTrack(1,1);

//////////////////////////////////////////////////////////////////////

PredictionTrackerBasePairProb::
PredictionTrackerBasePairProb(
		const InteractionEnergy & energy
		, const std::string & fileName
	)
 :	PredictionTracker()
	, energy(energy)
	, fileName(fileName)
	, probabilityThreshold(0.0001)
	, maxDotPlotSize(1000)
{
}

//////////////////////////////////////////////////////////////////////

PredictionTrackerBasePairProb::
~PredictionTrackerBasePairProb()
{
}

//////////////////////////////////////////////////////////////////////

void
PredictionTrackerBasePairProb::
updateOptimumCalled( const size_t i1, const size_t j1
					, const size_t i2, const size_t j2
					, const E_type curE
					)
{
}

//////////////////////////////////////////////////////////////////////

void
PredictionTrackerBasePairProb::
updateZ( PredictorMfeEns *predictor, SeedHandler *seedHandler )
{
	PredictorMfeEns2dSeedExtension* seedPredictor = dynamic_cast<PredictorMfeEns2dSeedExtension*>(predictor);
	isSeedPredictor = (seedPredictor != nullptr);

	// sequence strings
	const std::string & rna1 = energy.getAccessibility1().getSequence().asString();
	const std::string & reverseRna2 = energy.getAccessibility2().getAccessibilityOrigin().getSequence().asString();

	size_t s1 = energy.size1();
	size_t s2 = energy.size2();
	size_t n1 = energy.getAccessibility1().getMaxLength();
	size_t n2 = energy.getAccessibility2().getMaxLength();

	Z_type maxZ = 0.0;
	Interaction::Boundary interactionBoundary;

	// initialize Z_partition
	const PredictorMfeEns::Site2Z_hash & Z_partition = predictor->getZPartition();

	// create index of left/right boundaries
	for (auto z = Z_partition.begin(); z != Z_partition.end(); ++z) {
		// identify best interaction boundary
		Z_type Zstruct = z->second * energy.getBoltzmannWeight(energy.getE(z->first.i1, z->first.j1, z->first.i2, z->first.j2, E_type(0)));
		if (Zstruct > maxZ) {
			maxZ = Zstruct;
			interactionBoundary = z->first;
		}

		Interaction::BasePair iBP(z->first.i1, z->first.i2);
		Interaction::BasePair jBP(z->first.j1, z->first.j2);

		// create left and jBP index
		if (z->first.i1 != z->first.j1 && z->first.i2 != z->first.j2) {
			// encode iBP/jBP boundary
			// create left index
			rightExt[iBP].insert(jBP);
			// create right index
			if (seedHandler != NULL) {
				leftExt[jBP].insert(iBP);
			}
		}

	} // it (Z_partition)

	// Compute base-pair probabilities via combinations
	if (!isSeedPredictor) {
		computeBasePairProbsNoSeed(predictor);
	} else {
		computeBasePairProbs(seedPredictor, seedHandler);
	}

	// build plist
	struct vrna_elem_prob_s plist[structureProbs.size()+1];
	size_t i = 0;
	const Z_type Zall = predictor->getZall();
	for (auto sp = structureProbs.begin(); sp != structureProbs.end(); ++sp) {
		LOG_IF(Interaction::BasePair(sp->first.first,sp->first.second)==bpToTrack,DEBUG) << "prob: " << toString(bpToTrack) << " = " << sp->second <<"   Z = "<<sp->second*predictor->getZall();
		if ( (sp->second /Zall)  > probabilityThreshold) {
			plist[i].i = sp->first.first + 1;
			plist[i].j = sp->first.second + 1;
			plist[i].p = (sp->second /Zall);
			plist[i].type = 0; // base-pair prob
			i++;
		}
	}

	// create dot plot
	char *name = strdup(fileName.c_str());
	std::string comment =
	  "Intermolecular base-pair probabilities generated by "
	  INTARNA_PACKAGE_STRING
    " using Vienna RNA package "
    VRNA_VERSION;

	generateDotPlot(strdup(rna1.c_str()), strdup(reverseRna2.c_str()), name, plist, comment.c_str(), interactionBoundary);

}

////////////////////////////////////////////////////////////////////////////

void
PredictionTrackerBasePairProb::
computeBasePairProbsNoSeed( const PredictorMfeEns *predictor )
{
	for (auto z = predictor->getZPartition().begin(); z != predictor->getZPartition().end(); ++z) {
		assert( !Z_equal(z->second, 0) );

		Z_type bpProb = z->second * energy.getBoltzmannWeight(energy.getE(z->first.i1, z->first.j1, z->first.i2, z->first.j2, E_type(0)));

		Interaction::BasePair iBP(z->first.i1, z->first.i2);
		Interaction::BasePair jBP(z->first.j1, z->first.j2);

		// left end and single bp
		updateProb(iBP, bpProb);

		if (iBP < jBP) {
			// right end
			updateProb(jBP, bpProb);

			// inner (rightExt > jBP)
			for (auto right = rightExt[jBP].begin(); right != rightExt[jBP].end(); ++right) {
				Z_type innerProb = z->second * getHybridZ(z->first.j1, right->first, z->first.j2, right->second, predictor)
									 * energy.getBoltzmannWeight(energy.getE(z->first.i1, right->first, z->first.i2, right->second, -energy.getE_init()));
				updateProb(jBP, innerProb);
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////

void
PredictionTrackerBasePairProb::
computeBasePairProbs( const PredictorMfeEns2dSeedExtension *predictor, const SeedHandler* seedHandler )
{
	auto ZL_partition = predictor->getZLPartition();
	size_t i1, j1, i2, j2;
	for (auto z = predictor->getZPartition().begin(); z != predictor->getZPartition().end(); ++z) {
		i1 = z->first.i1;
		j1 = z->first.j1;
		i2 = z->first.i2;
		j2 = z->first.j2;

		Z_type bpZ;
		// i external left
		bpZ = getHybridZ(i1, j1, i2, j2, predictor)
				* energy.getBoltzmannWeight(energy.getE(i1, j1, i2, j2, E_type(0)));
		updateProb(Interaction::BasePair(i1,i2), bpZ);

		// j external right (and not single bp)
		if (i1!=j1) {
			updateProb(Interaction::BasePair(j1,j2), bpZ);
		}

		// loop internal k (inbetween i and j)
		for (size_t k1 = i1+1; k1 < j1; k1++) {
			for (size_t k2 = i2+1; k2 < j2; k2++) {

				Interaction::BasePair kBP(k1, k2);

				// k internal
				Z_type ZSleft = getHybridZ(i1, k1, i2, k2, predictor);
				Z_type ZSright = getHybridZ(k1, j1, k2, j2, predictor);

				// ... ZS:ZS
				bpZ = ZSleft * ZSright / energy.getBoltzmannWeight(energy.getE_init());

				// ... ZS:ZP
				if (!Z_equal(ZSleft, 0.0)) {
					// TODO: check if E_init is correct here ...
          bpZ += ZSleft * (getZHPartition(predictor, seedHandler, k1, j1, k2, j2) - ZSright) / energy.getBoltzmannWeight(energy.getE_init());
				}

				// ... ZP:ZS
				if (!Z_equal(ZSright, 0.0)) {
					// TODO: check if E_init is correct here ...
				  bpZ += (getZHPartition(predictor, seedHandler, i1, k1, i2, k2) - ZSleft) * ZSright / energy.getBoltzmannWeight(energy.getE_init());
				}

				// ... ZNL:seed:ZNR
				size_t si1 = RnaSequence::lastPos, si2 = RnaSequence::lastPos;
				size_t maxSeedLength1 = (seedHandler->getConstraint().getBasePairs() - 1) * energy.getMaxInternalLoopSize1();
				size_t maxSeedLength2 = (seedHandler->getConstraint().getBasePairs() - 1) * energy.getMaxInternalLoopSize2();
				while( seedHandler->updateToNextSeed(si1,si2
						, k1-std::min(k1, maxSeedLength1)
						, k1-1
						, k2-std::min(k2, maxSeedLength2)
						, k2-1) )
				{
					if (seedHandler->isSeedBasePair(si1, si2, k1, k2)) {
            bpZ += getZPartitionValue(&ZL_partition, Interaction::Boundary(i1,si1,i2,si2), true)
					        * energy.getBoltzmannWeight(seedHandler->getSeedE(si1, si2))
							    * getZRPartition(predictor, seedHandler, si1+seedHandler->getSeedLength1(si1,si2)-1, j1, si2+seedHandler->getSeedLength2(si1,si2)-1, j2, si1, si2);
					}
				}

				// add ED values, dangling ends, etc.
				bpZ *= energy.getBoltzmannWeight(energy.getE(i1, j1, i2, j2, E_type(0)));
				updateProb(kBP, bpZ);

			} // k2
		} // k1
	} // Z_partitions
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getZPartitionValue( const Site2Z_hash *Zpartition, const Interaction::Boundary & boundary, const bool addZInit )
{
	auto keyEntry = Zpartition->find(boundary);
	if ( Zpartition->find(boundary) == Zpartition->end() ) {
		return 0;
	} else {
		if (addZInit && boundary.i1 == boundary.j1 && boundary.i2 == boundary.j2) {
      return keyEntry->second * energy.getBoltzmannWeight(energy.getE_init());
		} else {
			return keyEntry->second;
		}
	}
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getZHPartition( const PredictorMfeEns2dSeedExtension *predictor, const SeedHandler* seedHandler
              , const size_t i1, const size_t j1
	            , const size_t i2, const size_t j2 )
{
	// single bp boundary with ZH == 1
	if (i1==j1 && i1==j2 && energy.areComplementary(i1,i2)) {
		return Z_type(1);
	}
	Interaction::Boundary boundary(i1,j1,i2,j2);

	LOG(DEBUG) << "request ZH @ " << i1 << ":" << j1 << ":" << i2 << ":" << j2;

	// TODO: first check if ZH is available
	Z_type ZH = getZPartitionValue(&predictor->getZHPartition(), Interaction::Boundary(i1,j1,i2,j2), false);
	if (Z_equal(ZH, 0.0)) {
		LOG(DEBUG) << "needs to be computed ...";
	}

	// TODO: then compute recursively
	
	return ZH;
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getZRPartition( const PredictorMfeEns2dSeedExtension *predictor, const SeedHandler* seedHandler
              , const size_t i1, const size_t j1
	            , const size_t i2, const size_t j2
							, const size_t sa1, const size_t sa2 )
{
	// TODO: memoization

	// single bp boundary with ZNR == 1
	if (i1==j1 && i1==j2 && energy.areComplementary(i1,i2)) {
		return Z_type(1);
	}
	Interaction::Boundary boundary(i1,j1,i2,j2);
	LOG(DEBUG) << "request ZR @ " << i1 << ":" << j1 << ":" << i2 << ":" << j2;

	Z_type partZ = getZHPartition(predictor, seedHandler, i1, j1, i2, j2);

	Z_type ZS = getHybridZ(boundary, predictor);

	assert( ZS <= partZ );
	partZ -= ZS;

	// iterate all seeds that overlap anchor seed sa on the right side
	Z_type Zoverlapping = 0;
	size_t si1 = RnaSequence::lastPos, si2 = RnaSequence::lastPos;
	size_t maxSeedLength1 = (seedHandler->getConstraint().getBasePairs() - 1) * energy.getMaxInternalLoopSize1();
	size_t maxSeedLength2 = (seedHandler->getConstraint().getBasePairs() - 1) * energy.getMaxInternalLoopSize2();
	while( seedHandler->updateToNextSeed(si1,si2
			, i1-std::min(i1, maxSeedLength1)
			, i1-1
			, i2-std::min(i2, maxSeedLength2)
			, i2-1) )
	{
		if (seedHandler->isSeedBasePair(si1, si2, i1, i2)) {
			LOG(DEBUG) << "overlapping seed @ " << si1 << ":" << si2;
			size_t sj1 = si1 + seedHandler->getSeedLength1(si1, si2) - 1;
			size_t sj2 = si2 + seedHandler->getSeedLength2(si1, si2) - 1;
			E_type EnonOverlap = PredictorMfeEns2dSeedExtension::getNonOverlappingEnergy(sa1, sa2, si1, si2, energy, *seedHandler);
			E_type Eoverlap = seedHandler->getSeedE(sa1, sa2) - EnonOverlap;
			partZ -= energy.getBoltzmannWeight(seedHandler->getSeedE(si1, si2) - Eoverlap)
			       * getZRPartition(predictor, seedHandler, sj1, j1, sj2, j2, si1, si2);
		}
	}

	// assert Zoverlapping <= partZ
	partZ -= Zoverlapping;

	return partZ;
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getHybridZ( const size_t i1, const size_t j1
					, const size_t i2, const size_t j2
					, const PredictorMfeEns *predictor)
{
	Interaction::Boundary boundary(i1, j1, i2, j2);
	return getHybridZ(boundary, predictor);
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getHybridZ( const Interaction::Boundary & boundary
					, const PredictorMfeEns *predictor)
{
	// check in original data
	if ( predictor->getZPartition().find(boundary) != predictor->getZPartition().end() ) {
		return predictor->getZPartition().find(boundary)->second;
	} else {
		// fall back
		return Z_type(0);
	}
}

////////////////////////////////////////////////////////////////////////////

Z_type
PredictionTrackerBasePairProb::
getBasePairProb( const size_t i1, const size_t i2
					     , const PredictorMfeEns *predictor)
{
	Interaction::BasePair bp(i1, i2);
	if ( structureProbs.find(bp) == structureProbs.end() ) {
		return Z_type(0);
	} else {
		return structureProbs[bp] / predictor->getZall();
	}
}

////////////////////////////////////////////////////////////////////////////

bool
PredictionTrackerBasePairProb::
generateDotPlot( const char *seq1, const char *seq2, const char *fileName
							 , const plist *pl, const char *comment
						   , const Interaction::Boundary interactionBoundary )
{
	FILE *file;
	file = fopen(fileName,"w");
	if (file == NULL) return false; /* failure */

	int bbox[4];
	bbox[0] = 0;
	bbox[1] = 0;
	bbox[2] = 72 * (strlen(seq1) + 3);
	bbox[3] = 72 * (strlen(seq2) + 3);

	size_t maxSize = std::max(bbox[2], bbox[3]);
	float scale = 1;
	if (maxSize > maxDotPlotSize) {
		scale = maxDotPlotSize / (float)maxSize;
		bbox[2] *= scale;
		bbox[3] *= scale;
	}

	fprintf(file,
          "%%!PS-Adobe-3.0 EPSF-3.0\n"
          "%%%%Creator: IntaRNA\n"
          "%%%%Title: RNA Dot Plot\n"
          "%%%%BoundingBox: %d %d %d %d\n"
          "%%%%DocumentFonts: Helvetica\n"
          "%%%%Pages: 1\n"
          "%%%%EndComments\n",
          bbox[0], bbox[1], bbox[2], bbox[3]);

	// scaling
	fprintf(file,
		      "%%%%BeginProcSet: epsffit 1 0\n"
		      "gsave\n"
		      "%f 0 translate\n"
	        "%f %f scale\n"
		      "%%%%EndProcSet\n\n",
				  scale, scale, scale);

  // comment

	if (comment) {
    fprintf(file, "%%%% %s\n", comment);
  }

	fprintf(file, "/DPdict 100 dict def\n");
	fprintf(file, "DPdict begin\n");

	// ps template

	fprintf(file, dotplotTemplate);
  fprintf(file, "end\n");
	fprintf(file, "DPdict begin\n");

	// sequences

	unsigned int i, length;
  length = strlen(seq1);
  fprintf(file, "/sequence1 { (\\\n");
  i = 0;
  while (i < length) {
    fprintf(file, "%.255s\\\n", seq1 + i);  /* no lines longer than 255 */
    i += 255;
  }
  fprintf(file, ") } def\n");
	fprintf(file, "/len { sequence1 length } bind def\n\n");
	length = strlen(seq2);
  fprintf(file, "/sequence2 { (\\\n");
  i = 0;
  while (i < length) {
    fprintf(file, "%.255s\\\n", seq2 + i);  /* no lines longer than 255 */
    i += 255;
  }
  fprintf(file, ") } def\n");
	fprintf(file, "/len2 { sequence2 length } bind def\n\n");

	fprintf(file, "72 72 translate\n"
	               "72 72 scale\n");

  fprintf(file, "/Helvetica findfont 0.95 scalefont setfont\n\n");

	fprintf(file,"drawseq1\n");
	fprintf(file,"drawseq2\n");

	// basepair data

	fprintf(file,"%%data starts here\n");

	fprintf(file, "\n%%draw the grid\ndrawgrid\n\n");
	fprintf(file,"%%start of base pair probability data\n");

  fprintf(file, "/coor [\n");

	for (const plist *pl1 = pl; pl1->i > 0; pl1++) {
    if (pl1->type == 0) {
      fprintf(file, "%1.9f %d %d boxgray\n", sqrt(pl1->p), pl1->i, pl1->j);
    }
  }

  fprintf(file, "] def\n");

	// print frame
	fprintf(file,
		      "0.03 setlinewidth\n\
           %1.1f %1.1f %zu %zu rectangle\n\
					 0 0 0 setrgbcolor\n\
           stroke\n", 0.5, 0.5, strlen(seq1), strlen(seq2));

	// print best interaction outline
	fprintf(file,
		      "0.03 setlinewidth\n\
           %1.1f %1.1f %zu %zu rectangle\n\
					 1 0 0 setrgbcolor\n\
           stroke\n", (float)interactionBoundary.i1 + 0.5, (float)interactionBoundary.i2 + 0.5, interactionBoundary.j1 - interactionBoundary.i1 + 1, interactionBoundary.j2 - interactionBoundary.i2 + 1);

	fprintf(file, "showpage\n"
	            "end\n"
              "%%%%EOF\n");

	fclose(file);
	return true; /* success */
}

////////////////////////////////////////////////////////////////////////////

} // namespace
